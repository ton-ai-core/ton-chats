{
  "id": "2203874215",
  "name": "TOLK lang",
  "type": "public_channel",
  "messages": [
    {
      "id": 12,
      "type": "message",
      "date": "2025-01-16T09:12:01.000Z",
      "date_unixtime": "1737018721",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "Tolk is a language for writing smart contracts in TON. Think of Tolk as the \"next‑generation FunC\". Tolk compiler is literally a fork of FunC compiler, introducing familiar syntax similar to TypeScript, but leaving all low-level optimizations untouched.\n\nTolk was announced at the TON Gateway in Dubai in November 2024.\n\nThis channel will contain updates and releases of Tolk, highlights of planned features, and occasional posts about compilers and language design in general.\n\nUseful links:\n- Documentation\n- GitHub (Tolk is a part of ton-blockchain repo)\n- IDE plugins: \"TON\" in JetBrains, \"Tolk\" in VS Code\n- Read an interview about TOLK history and plans\n- Watch announcement on YouTube"
    },
    {
      "id": 13,
      "type": "message",
      "date": "2025-01-21T09:12:01.000Z",
      "date_unixtime": "1737450721",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "Two months of absence: what was going on?\n\nTwo months have passed since the announcement of Tolk. You might be wondered, what was going on and why there we no releases yet.\n\nThroughout all November, I've been working on the vision of the future. My goal was to \"visualize\" what Tolk v1.0 should look like. What's the language we're all targeting to, so that it solves lots of practical problems, avoids manual cells/slices manipulation, provides sufficient mechanisms for ABI generation, but still being zero overhead. I have created a giant roadmap (40 PDF pages!) describing the vision, and how, step by step, we're going to reach it.\n\nThroughout all December, I've been constantly working on the compiler's kernel. As you know, Tolk is a fork of FunC. FunC compiler internals are very challenging to be extended and modified. The way FunC looks like is just a mirror of its internal implementation. Heading towards the future, I had to partially \"untangle\" this \"legacy FunC core\", so that in the future, it will be able to \"interbreed\" with features it was not originally designed for.\n\nCurrently I am done with this preparation. Tolk v0.7 has just been released. It contains a fully rewritten semantic analysis kernel (though almost invisible to the end user, huh).\n\n✅ Notable changes in Tolk v0.7:\n1. Under the hood: refactor and revamp compiler internals. AST-level semantic analysis kernel\n2. Under the hood: rewrite the type system from Hindley-Milner to static typing\n3. Clear and readable error messages on type mismatch\n4. Generic functions fun f<T>(...) and instantiations like f<int>(...)\n5. The bool type\n6. Type casting via value as T\n\nPR on GitHub with detailed info. IDE plugins are updated accordingly.\n\nBTW, a new version of blueprint was also released. You can now update compilers (Tolk / FunC / Tact) independently, they became peer dependencies.\n\nP.S. I'll uncover the details about planned Tolk v1.0 quite soon."
    },
    {
      "id": 14,
      "type": "message",
      "date": "2025-01-28T09:12:01.000Z",
      "date_unixtime": "1738055521",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "The Hindley-Milner type system, and Why Tolk decided to avoid it\n\nYou know, that FunC is \"functional C\". But do you know, what makes it \"functional\"? Not its low-level nature. Not its peculiar syntax. And even not the ~ tilda. \"Functional\" is mostly about the Hindley-Milner type system.\n\nThe Hindley-Milner type system is a common approach for functional languages, where types are inferred from usage through unification. As a result, type declarations are not necessary:\n\n() f(a, b) {\n    return a + b;   // a and b now int, since `+` (int, int)\n}\n\n\nFor example,\n\n() f(slice s) {} \n\nvar s = null;\nf(s);  // infer s as slice, since f accepts slice\n\n\nFor example,\n\nint f(x) {\n    (a, b) = (0, x);\n    return a + b;   // x becomes int, since x and b edge\n}\n\n\nThis \"unification\", looking pretty at first glance, arises problems, if we actually do not want types to unify. Imagine, we want to have nullable types: int (not nullable) and int? (nullable), so that we can assign null only to int?. What would Hindley-Milner think about this?\n\nvar x = 0;   // unify(Hole, Int) = Int\n...\nx = null;    // unify(Int, Nullable<Hole>) = Nullable<Int>\n\n\nInstead of an error, Hindley-Milner would perform unification and result in x: int?. Not as we wanted to, right? (while it can be \"fixed\", it would step away from HM's nature)\n\nA fun fact: you don't notice these problems in FunC. Because FunC's type system is very limited. But Tolk will have bool, fixed-width integers, nullability, smart casts, structures, and generics — these problems will become significant. Hindley-Milner will clash with structure methods, struggle with proper generics, and become entirely impractical for union types (despite theoretical claims that it was \"designed for union types\").\n\nThe goal is to have predictable, explicit, and positionally-checked static typing. While Hindley-Milner is powerful, it's actually \"type inference for the poor\" — simple to implement when there's no time to fundamentally design the language.\n\nBy the way, unreadable type errors also stem from Hindley-Milner:\n\nerror: function return type (int, int) cannot be unified with implicit end-of-block return type (int, ()): cannot unify type () with int\n\n\nWhat the programmer actually wants to see is:\n\n1) can not assign `(int, slice)` to variable of type `(int, int)`\n2) can not call method for `builder` with object of type `int`\n3) missing `return`\n\n\nThat's why Tolk v0.7 contains a fully rewritten type system, encoupled with clear error messages and an IDE plugin with type inference included. It's the groundwork for future enhancements."
    },
    {
      "id": 16,
      "type": "message",
      "date": "2025-02-11T09:12:01.000Z",
      "date_unixtime": "1739265121",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "Tolk v0.8: preparation for structures\n\nA new version of Tolk was released several days ago. We're starting a way to eventually implement structures with auto packing to/from cells. This will take several steps (each publicly released), it's the first one.\n\n✅ Notable changes in Tolk v0.8:\n1. Syntax tensorVar.0 and tupleVar.0, both for reading and writing\n2. Allow cell, slice, etc. to be valid identifiers\n\nPR on GitHub with detailed info.\n\nUsing syntax `tensorVar.{i}` and `tupleVar.{i}`, you can access tensors/tuples by indices without unpacking them.\n\nIt works for tensors:\n\nvar t = (5, someSlice, someBuilder);   // 3 stack slots\nt.0                     // 5\nt.0 = 10;               // t is now (10, ...)\nt.0 += 1;               // t is now (11, ...)\nincrement(mutate t.0);  // t is now (12, ...)\nt.0.increment();        // t is now (13, ...)\n\nt.1         // slice\nt.100500    // compilation error\n\n\nIt works for tuples (does asm INDEX/SETINDEX under the hood):\n\nvar t = [5, someSlice, someBuilder];   // 1 tuple on a stack with 3 items\nt.0                     // \"0 INDEX\", reads 5\nt.0 = 10;               // \"0 SETINDEX\", t is now [10, ...]\nt.0 += 1;               // \"0 INDEX\" to read 10, \"0 SETINDEX\" to write 11\nincrement(mutate t.0);  // also, the same way\nt.0.increment();        // also, the same way\n\nt.1         // \"1 INDEX\", it's slice\nt.100500    // compilation error\n\n\nIt works for nesting var.{i}.{j}. It works for nested tensors, nested tuples, tuples nested into tensors. It works for mutate. It works for globals.\n\nWhy is this essential?\n\nIn the future, we'll have structures, declared like this:\n\nstruct User {\n    id: int;\n    name: slice;\n}\n\n\nStructures will be stored like tensors on a stack:\n\nvar u: User = { id: 5, name: \"\" };\n// u is actually 2 slots on a stack, the same as\nvar u: (int, slice) = (5, \"\");\n\nfun getUser(): User { ... }\n// on a stack, the same as\nfun getUser(): (int, slice) { ... }\n\n\nIt means, that `obj.{field}` is exactly the same as `tensorVar.{i}`:\n\nvar u: User = ...;   // u: (int, slice) = ...\nu.id;                // u.0\nu.id = 10;           // u.0 = 10\n\n\nSame goes for nested objects:\n\nstruct Storage {\n    lastUpdated: int;\n    owner: User;\n}\n\ns.lastUpdated        // s.0\ns.owner.id           // s.1.0\n\n\nSo, implementing indexed access for tensors/tuples covering all scenarios is a direct step towards structures."
    },
    {
      "id": 17,
      "type": "message",
      "date": "2025-03-07T09:12:01.000Z",
      "date_unixtime": "1741338721",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "𒀟 Tolk v0.9: nullable types, null safefy, control flow, smart casts\n\nTolk v0.9 introduces nullable types: int?, cell?, and T?, bringing null safety to your code. The compiler prevents using nullable values without checks, but thanks to smart casts, this feels smooth and natural.\n\n✅ Notable changes in Tolk v0.9:\n\n1. Nullable types int?, cell?, etc.; null safety\n2. Standard library updated to reflect nullability\n3. Smart casts, like in TypeScript in Kotlin\n4. Operator ! (non-null assertion)\n5. Code after throw is treated unreachable\n6. The never type\n\nPR on GitHub with detailed info.\n\n✔ Nullable types and null safety\n\nIn FunC, null was implicitly assignable to any primitive type — too permissive. A variable declared as int could still hold null at runtime, leading to TVM exceptions if used incorrectly.\n\nTolk now forces you to explicitly mark nullable values. This aligns with TypeScript T | null and Kotlin, preventing unintended null usage.\n\n\nvalue = x > 0 ? 1 : null;  // int?\n\nvalue + 5;               // error\ns.storeInt(value);       // error\n\nif (value != null) {\n    value + 5;           // ok\n    s.storeInt(value);   // ok\n}\n\n\n* any type can be nullable: cell?, [int, slice]?, (int, cell)?\n* no more unexpected TVM exceptions due to null\n* at runtime, int? and cell? occupy just one stack slot — zero overhead\n\n✔ Smart casts (via control flow graph)\n\nOnce a nullable value is checked, the compiler automatically refines its type:\n\nif (lastCell != null) {\n    // here lastCell is `cell`, not `cell?`\n}\n\n\nor:\n\nif (lastCell == null || prevCell == null) {\n    return;\n}\n// both lastCell and prevCell are `cell`\n\n\nor:\n\nvar x: int? = ...;\nif (x == null) {\n    x = random();\n}\n// here x is `int`\n\n\nSmart casts ensure code is safe while remaining gas-efficient (compile-time only).\n\n✔ Operator `!` (non-null assertion)\n\nIf you know a value can't be null, use the ! operator to bypass nullability checks:\n\n// this key 100% exists, make it `cell`, not `cell?`\nvalidators = getBlockchainConfigParam(16)!;\n\n\nIt's useful for low-level TVM functions (dicts, particularly), when you have guarantees outside the code. Use with care!\n\n✔ The `never` type\n\nNow, you can declare \"always-throwing functions\":\n\nfun alwaysThrows(): never {\n    throw 123;\n}\n\nfun f() {\n    ...\n    alwaysThrows();  // no return needed after this\n}\n\n\nnever also occurs implicitly when a condition is impossible:\n\nvar v = 0;\n// compiler warning: `int` can never be `null`\nif (v == null) {\n    // v is `never`\n}\n\n\n... this is just the beginning! Nullable tensors, tricky smart casts, and low-level null safety details — all explained in the PR.\n\n🌳 Null safety is smooth, intuitive, and enforced at compile time — no runtime cost, no extra gas, just safer code."
    },
    {
      "id": 18,
      "type": "message",
      "date": "2025-03-20T09:12:01.000Z",
      "date_unixtime": "1742461921",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "🫧 Tolk v0.10: preparing for serialization — intN, bytesN, coins\n\nThis update lays the foundation of future auto-packing to/from cells by solving one critical question: \nHow should fields be serialized?\n\n✅ Notable changes in Tolk v0.10:\n\n1. Fixed-size integer types: int32, uint64, etc.\n2. Type coins and function ton(\"0.05\")\n3. Types bytesN and bitsN (backed by slices at TVM)\n4. Replace \"...\"c postfixes with stringCrc32(\"...\") functions\n5. Trailing comma support\n\nPR on GitHub with detailed info.\n\n❓ Fixed-size integers? In TVM? What?\n\nImagine Tolk already has structures, and we define an incoming message:\n\nstruct CounterIncrement {\n    counter_id: int;\n    inc_by: int;\n}\n\n\nA client sends this message following the TL/B schema:\n\ncounterIncrement \n    counter_id:int32 \n    inc_by:int64\n    = CounterIncrement;\n\n\nBut how do we tell the compiler that counter_id is int32 and inc_by is int64? This information is missing in the struct definition.\n\n✖ Rejected approaches: why they fail\n\nSeveral syntax ideas were considered:\n\n\n// type casting?\ncounter_id: int as int32; \ninc_by: int as int64;\n\n// inline annotations?\ncounter_id: int @int32;\ninc_by: int @int64;\n\n// annotations above fields?\n@serialize(int32)\ncounter_id: int;\n@serialize(int64)\ninc_by: int;\n\n\nEach of these quickly breaks down when handling more complex cases. \n\nFor example, how would we handle TL-B Maybe int32? Would we write:\n\n// this?\ninc_by: (int as int32)?;\n// or this?\ninc_by: int? as int32?;\n// or this?\ninc_by: Maybe<int> as Maybe<int32>;\n\n\nAnd what about TL/B Both (Maybe int32) int64?\n\n// this?\nmy_data: Both<Maybe<int as int32>, int as int64>;\n// or this?\nmy_data: Both<Maybe<int>, int> as Both<Maybe<int32>, int64>;\n// or how??\n\n\nWith every new case, the syntax becomes more complex, ambiguous, and error-prone.\n\n✔ The solution: `int32` as a first-class type\n\n\nstruct CounterIncrement {\n    counter_id: int32;\n    inc_by: int64;\n}\n\n\nNo annotations. No confusing as syntax. No ambiguity.\n\nThis scales perfectly:\n\nstruct MyMsg {\n    inc_by: int32?;\n    my_data: (int32?, int64);\n}\n\n\nThese are distinct types. A variable can be int32 and similar:\n\nvar op: int32 = ...;\nvar query_id: uint64 = ...;\n\n\nThis makes serialization predictable, structured, and error-free.\n\n✔ What about overflow?\n\nA reasonable question: what happens if a value exceeds the limit?\n\nvar v: uint8 = 255;\nv += 1;    // ???\n\n\nAnswer: no runtime overflow or clamping! It's just int at TVM.\n\n* arithmetic works normally – v becomes 256\n* no extra gas cost – no runtime bounds checks\n* overflow will only happen at serialization\n\n\nstruct Resp {\n    outValue: uint8;\n}\n\nresp.outValue = v;   // 256\nresp.toCell();       // a runtime \"overflow\" error\n\n\n✔ Why is this the best approach?\n\nThink of smart contracts as a black box:\n- inputs are encoded (int32, uint64, etc.)\n- inside the contract, arithmetic uses full 257-bit precision\n- outputs are serialized again — overflow happens only at this stage\n\nThis is similar to how mulDivFloor(x,y,z) uses 513-bit precision internally. Your contract keeps precision internally and only enforces constraints at the border with an outside world.\n\n🌳 Tolk will follow a type-based philosophy\n\nThis post covered the foundation of automatic serialization. The right way is to have a rich type system. Having nested types, having generics, having aliases — will allow to describe every practical TL/B case, but at a language level.\n\nIn v0.10, we introduce intN (fixed integers), bytesN (definite slices), coins (variadic integers), and some more additions. Read the details in the PR.\n\nHow will Either L R and even more complex TL/B structures be expressed? \nStay tuned for the next update..."
    },
    {
      "id": 19,
      "type": "message",
      "date": "2025-04-08T09:12:01.000Z",
      "date_unixtime": "1744103521",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "🫧 Tolk v0.11: type aliases, union types, and pattern matching\n\nThis update might confuse you at first. You may wonder: \"Why do we need this? How will it be useful?\". But in the end, you'll see how everything comes together bringing seamless and generalized message handling.\n\n✅ Notable changes in Tolk v0.11:\n\n1. Type aliases type NewName = <existing type>\n2. Union types T1 | T2 | ...\n3. Pattern matching for types\n4. Operators is and !is\n5. Pattern matching for expressions\n6. Semicolon for the last statement in a block can be omitted\n\nPR on GitHub with detailed info.\n\n✔ Type aliases\n\nTolk now supports type aliases, similar to TypeScript and Rust.\n\n\ntype UserId = int32;\ntype MaybeOwnerHash = bytes32?;\n\n\nAn alias creates a new name for an existing type but remains interchangeable with it. No performance overhead — a compile-time feature.\n\n✔ Union types `T1 | T2 | ...`\n\nThey now allow a variable to hold multiple possible types. \n\n\nfun whatFor(a: bits8 | bits256): slice | UserId { ... }\n\nvar result = whatFor(...);  // slice | UserId\n\n\nNullable types T? are now formally T | null. \n\nAt the TVM level, union types work as tagged unions — similar to Rust enums but more flexible.\n\n✔ Pattern matching\n\nThe only way to work with union types is matching them:\n\n\nmatch (result) {\n    slice  => { /* result is slice here  */ }\n    UserId => { /* result is UserId here */ }\n}\n\n\nMatching is based on smart casts — inside each branch, the variable is automatically narrowed to the matched type.\n \nIt can also be used as an expression:\n\n\ntype Pair2 = (int, int);\ntype Pair3 = (int, int, int);\n\nfun getLast(tensor: Pair2 | Pair3) {\n    return match (tensor) {\n        Pair2 => tensor.1,\n        Pair3 => tensor.2,\n    }\n}\n\n\nSo, `match` + smart casts are our way for union types. You may notice that it's close to enums in Rust. But we don't have enum. Union types are more general and powerful.\n\n✔ `match` for expressions\n\n\nval nextValue = match (curValue) {\n    1 => 0,\n    0 => 1,\n    else => -1\n};\n\n\nAs you see, match also works for constant expressions, similar to switch in other languages.\n\n✔ Union types and TL/B `Either`\n\nT1 | T2 will be directly mapped to TL-B (Either T1 T2). \nLook how clean this is: (Either SmallPayload LargePayload) becomes\n\n\nstruct StoragePart {\n    data: SmallPayload | LargePayload;\n    // (de)serialized as '0' + ... or '1' + ...\n}\n\nmatch (s.data) {\n    SmallPayload => ...\n    LargePayload => ...\n}\n\n\nNo need to manually handle bits from the slice — it's naturally expressed in the type system!\n\n✔ Union types and TL/B constructors\n\nT1 | T2 | ... is a typed way to describe multiple constructors from TL/B. Generally, they can be used anywhere inside a storage or a message. \n\nMoreover — handling incoming messages is beautifully expressed with union types.\n\n✔ Union types and future structures\n\nThe ultimate goal? You'll describe each incoming message as a struct, create a union type for them, parse a slice, and just match over variants:\n\n\n// don't mind about opcodes yet\nstruct CounterIncBy { byValue: int32 }\nstruct CounterReset {}\nstruct ... other messages\n\ntype IncomingMessage = CounterIncBy | CounterReset | ...;\n\n// ... after parsing a message\nmatch (msg) {\n    CounterIncBy => {\n        newCounter = curCounter + msg.byValue\n    }\n    CounterReset => {\n        newCounter = 0\n    }\n    ...\n}\n\n\n🌳 So, union types (that perfectly work with tensors) will seamlessly work with structures. With union types, you will declare both Either and different kinds of messages. Combined with intN and other types, they will allow to express (almost) any practical TL/B construction. They are not limited to message routing — in other words, message routing does not differ from handling any field, any storage, or any cell in general."
    }
  ]
}