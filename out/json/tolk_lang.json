{
  "id": "2203874215",
  "name": "TOLK lang",
  "type": "public_channel",
  "messages": [
    {
      "id": 12,
      "type": "message",
      "date": "2025-01-16T09:12:01.000Z",
      "date_unixtime": "1737018721",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "Tolk is a language for writing smart contracts in TON. Think of Tolk as the \"nextâ€‘generation FunC\". Tolk compiler is literally a fork of FunC compiler, introducing familiar syntax similar to TypeScript, but leaving all low-level optimizations untouched.\n\nTolk was announced at the TON Gateway in Dubai in November 2024.\n\nThis channel will contain updates and releases of Tolk, highlights of planned features, and occasional posts about compilers and language design in general.\n\nUseful links:\n- Documentation\n- GitHub (Tolk is a part of ton-blockchain repo)\n- IDE plugins: \"TON\" in JetBrains, \"Tolk\" in VS Code\n- Read an interview about TOLK history and plans\n- Watch announcement on YouTube"
    },
    {
      "id": 13,
      "type": "message",
      "date": "2025-01-21T09:12:01.000Z",
      "date_unixtime": "1737450721",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "Two months of absence: what was going on?\n\nTwo months have passed since theÂ announcement of Tolk. You might be wondered, what was going on and why there we no releases yet.\n\nThroughout all November, I've been working on the vision of the future. My goal was to \"visualize\" what Tolk v1.0 should look like. What's the language we're all targeting to, so that it solves lots of practical problems, avoids manual cells/slices manipulation, provides sufficient mechanisms for ABI generation, but still being zero overhead. I have created a giant roadmap (40 PDF pages!) describing the vision, and how, step by step, we're going to reach it.\n\nThroughout all December, I've been constantly working on the compiler's kernel. As you know, Tolk is a fork of FunC. FunC compiler internals are very challenging to be extended and modified. The way FunC looks like is just a mirror of its internal implementation. Heading towards the future, I had to partially \"untangle\" this \"legacy FunC core\", so that in the future, it will be able to \"interbreed\" with features it was not originally designed for.\n\nCurrently I am done with this preparation. Tolk v0.7 has just been released. It contains a fully rewritten semantic analysis kernel (though almost invisible to the end user, huh).\n\nâœ… Notable changes in Tolk v0.7:\n1. Under the hood: refactor and revamp compiler internals. AST-level semantic analysis kernel\n2. Under the hood: rewrite the type system from Hindley-Milner to static typing\n3. Clear and readable error messages on type mismatch\n4. Generic functionsÂ fun f<T>(...)Â and instantiations likeÂ f<int>(...)\n5. TheÂ boolÂ type\n6. Type casting viaÂ value as T\n\nPR on GitHub with detailed info. IDE plugins are updated accordingly.\n\nBTW, a new version of blueprint was also released. You can now update compilers (Tolk / FunC / Tact) independently, they became peer dependencies.\n\nP.S. I'll uncover the details about planned Tolk v1.0 quite soon."
    },
    {
      "id": 14,
      "type": "message",
      "date": "2025-01-28T09:12:01.000Z",
      "date_unixtime": "1738055521",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "The Hindley-Milner type system, and Why Tolk decided to avoid it\n\nYou know, that FunC is \"functional C\". But do you know, what makes it \"functional\"? Not its low-level nature. Not its peculiar syntax. And even not theÂ ~Â tilda. \"Functional\" is mostly about the Hindley-Milner type system.\n\nThe Hindley-Milner type system is a common approach for functional languages, where types are inferred from usage through unification. As a result, type declarations are not necessary:\n\n() f(a, b) {\n    return a + b;   // a and b now int, since `+` (int, int)\n}\n\n\nFor example,\n\n() f(slice s) {} \n\nvar s = null;\nf(s);  // infer s as slice, since f accepts slice\n\n\nFor example,\n\nint f(x) {\n    (a, b) = (0, x);\n    return a + b;   // x becomes int, since x and b edge\n}\n\n\nThis \"unification\", looking pretty at first glance, arises problems, if we actually do not want types to unify. Imagine, we want to have nullable types: int (not nullable) and int? (nullable), so that we can assign null only to int?. What would Hindley-Milner think about this?\n\nvar x = 0;   // unify(Hole, Int) = Int\n...\nx = null;    // unify(Int, Nullable<Hole>) = Nullable<Int>\n\n\nInstead of an error, Hindley-Milner would perform unification and result in x: int?. Not as we wanted to, right? (while it can be \"fixed\", it would step away from HM's nature)\n\nA fun fact: you don't notice these problems in FunC.Â Because FunC's type system is very limited. But Tolk will have bool, fixed-width integers, nullability, smart casts, structures, and generics â€” these problems will become significant. Hindley-Milner will clash with structure methods, struggle with proper generics, and become entirely impractical for union types (despite theoretical claims that it was \"designed for union types\").\n\nThe goal is to have predictable, explicit, and positionally-checked static typing. While Hindley-Milner is powerful, it's actually \"type inference for the poor\" â€” simple to implement when there's no time to fundamentally design the language.\n\nBy the way, unreadable type errors also stem from Hindley-Milner:\n\nerror: function return type (int, int) cannot be unified with implicit end-of-block return type (int, ()): cannot unify type () with int\n\n\nWhat the programmer actually wants to see is:\n\n1) can not assign `(int, slice)` to variable of type `(int, int)`\n2) can not call method for `builder` with object of type `int`\n3) missing `return`\n\n\nThat's why Tolk v0.7 contains a fully rewritten type system, encoupled with clear error messages and an IDE plugin with type inference included. It's the groundwork for future enhancements."
    },
    {
      "id": 16,
      "type": "message",
      "date": "2025-02-11T09:12:01.000Z",
      "date_unixtime": "1739265121",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "Tolk v0.8: preparation for structures\n\nA new version of Tolk was released several days ago. We're starting a way to eventually implement structures with auto packing to/from cells. This will take several steps (each publicly released), it's the first one.\n\nâœ… Notable changes in Tolk v0.8:\n1. SyntaxÂ tensorVar.0Â andÂ tupleVar.0, both for reading and writing\n2. AllowÂ cell,Â slice, etc. to be valid identifiers\n\nPR on GitHub with detailed info.\n\nUsing syntaxÂ `tensorVar.{i}`Â andÂ `tupleVar.{i}`, you can access tensors/tuples by indices without unpacking them.\n\nIt works for tensors:\n\nvar t = (5, someSlice, someBuilder);   // 3 stack slots\nt.0                     // 5\nt.0 = 10;               // t is now (10, ...)\nt.0 += 1;               // t is now (11, ...)\nincrement(mutate t.0);  // t is now (12, ...)\nt.0.increment();        // t is now (13, ...)\n\nt.1         // slice\nt.100500    // compilation error\n\n\nIt works for tuples (does asm INDEX/SETINDEX under the hood):\n\nvar t = [5, someSlice, someBuilder];   // 1 tuple on a stack with 3 items\nt.0                     // \"0 INDEX\", reads 5\nt.0 = 10;               // \"0 SETINDEX\", t is now [10, ...]\nt.0 += 1;               // \"0 INDEX\" to read 10, \"0 SETINDEX\" to write 11\nincrement(mutate t.0);  // also, the same way\nt.0.increment();        // also, the same way\n\nt.1         // \"1 INDEX\", it's slice\nt.100500    // compilation error\n\n\nIt works for nestingÂ var.{i}.{j}. It works for nested tensors, nested tuples, tuples nested into tensors. It works forÂ mutate. It works for globals.\n\nWhy is this essential?\n\nIn the future, we'll have structures, declared like this:\n\nstruct User {\n    id: int;\n    name: slice;\n}\n\n\nStructuresÂ will be stored like tensors on a stack:\n\nvar u: User = { id: 5, name: \"\" };\n// u is actually 2 slots on a stack, the same as\nvar u: (int, slice) = (5, \"\");\n\nfun getUser(): User { ... }\n// on a stack, the same as\nfun getUser(): (int, slice) { ... }\n\n\nIt means, thatÂ `obj.{field}`Â is exactly the same asÂ `tensorVar.{i}`:\n\nvar u: User = ...;   // u: (int, slice) = ...\nu.id;                // u.0\nu.id = 10;           // u.0 = 10\n\n\nSame goes for nested objects:\n\nstruct Storage {\n    lastUpdated: int;\n    owner: User;\n}\n\ns.lastUpdated        // s.0\ns.owner.id           // s.1.0\n\n\nSo, implementing indexed access for tensors/tuples covering all scenarios is a direct step towards structures."
    },
    {
      "id": 17,
      "type": "message",
      "date": "2025-03-07T09:12:01.000Z",
      "date_unixtime": "1741338721",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "ğ’€Ÿ Tolk v0.9: nullable types, null safefy, control flow, smart casts\n\nTolk v0.9 introduces nullable types: int?, cell?, and T?, bringing null safety to your code. The compiler prevents using nullable values without checks, but thanks to smart casts, this feels smooth and natural.\n\nâœ… Notable changes in Tolk v0.9:\n\n1. Nullable types int?, cell?, etc.; null safety\n2. Standard library updated to reflect nullability\n3. Smart casts, like in TypeScript in Kotlin\n4. Operator ! (non-null assertion)\n5. Code after throw is treated unreachable\n6. The never type\n\nPR on GitHub with detailed info.\n\nâœ” Nullable types and null safety\n\nIn FunC, null was implicitly assignable to any primitive type â€” too permissive. A variable declared as int could still hold null at runtime, leading to TVM exceptions if used incorrectly.\n\nTolk now forces you to explicitly mark nullable values. This aligns with TypeScript T | null and Kotlin, preventing unintended null usage.\n\n\nvalue = x > 0 ? 1 : null;  // int?\n\nvalue + 5;               // error\ns.storeInt(value);       // error\n\nif (value != null) {\n    value + 5;           // ok\n    s.storeInt(value);   // ok\n}\n\n\n* any type can be nullable: cell?, [int, slice]?, (int, cell)?\n* no more unexpected TVM exceptions due to null\n* at runtime, int? and cell? occupy just one stack slot â€” zero overhead\n\nâœ” Smart casts (via control flow graph)\n\nOnce a nullable value is checked, the compiler automatically refines its type:\n\nif (lastCell != null) {\n    // here lastCell is `cell`, not `cell?`\n}\n\n\nor:\n\nif (lastCell == null || prevCell == null) {\n    return;\n}\n// both lastCell and prevCell are `cell`\n\n\nor:\n\nvar x: int? = ...;\nif (x == null) {\n    x = random();\n}\n// here x is `int`\n\n\nSmart casts ensure code is safe while remaining gas-efficient (compile-time only).\n\nâœ” Operator `!` (non-null assertion)\n\nIf you know a value can't be null, use the ! operator to bypass nullability checks:\n\n// this key 100% exists, make it `cell`, not `cell?`\nvalidators = getBlockchainConfigParam(16)!;\n\n\nIt's useful for low-level TVM functions (dicts, particularly), when you have guarantees outside the code. Use with care!\n\nâœ” The `never` type\n\nNow, you can declare \"always-throwing functions\":\n\nfun alwaysThrows(): never {\n    throw 123;\n}\n\nfun f() {\n    ...\nÂ  Â  alwaysThrows();Â  // no return needed after this\n}\n\n\nnever also occurs implicitly when a condition is impossible:\n\nvar v = 0;\n// compiler warning: `int` can never be `null`\nif (v == null) {\nÂ  Â  // v is `never`\n}\n\n\n... this is just the beginning! Nullable tensors, tricky smart casts, and low-level null safety details â€” all explained in the PR.\n\nğŸŒ³ Null safety is smooth, intuitive, and enforced at compile time â€” no runtime cost, no extra gas, just safer code."
    },
    {
      "id": 18,
      "type": "message",
      "date": "2025-03-20T09:12:01.000Z",
      "date_unixtime": "1742461921",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "ğŸ«§ Tolk v0.10: preparing for serialization â€” intN, bytesN, coins\n\nThis update lays the foundation of future auto-packing to/from cells by solving one critical question: \nHow should fields be serialized?\n\nâœ… Notable changes in Tolk v0.10:\n\n1. Fixed-size integer types: int32, uint64, etc.\n2. Type coins and function ton(\"0.05\")\n3. Types bytesN and bitsN (backed by slices at TVM)\n4. Replace \"...\"c postfixes with stringCrc32(\"...\") functions\n5. Trailing comma support\n\nPR on GitHub with detailed info.\n\nâ“ Fixed-size integers? In TVM? What?\n\nImagine Tolk already has structures, and we define an incoming message:\n\nstruct CounterIncrement {\n    counter_id: int;\n    inc_by: int;\n}\n\n\nA client sends this message following the TL/B schema:\n\ncounterIncrement \n    counter_id:int32 \n    inc_by:int64\n    = CounterIncrement;\n\n\nBut how do we tell the compiler that counter_id is int32 and inc_by is int64? This information is missing in the struct definition.\n\nâœ– Rejected approaches: why they fail\n\nSeveral syntax ideas were considered:\n\n\n// type casting?\ncounter_id: int as int32; \ninc_by: int as int64;\n\n// inline annotations?\ncounter_id: int @int32;\ninc_by: int @int64;\n\n// annotations above fields?\n@serialize(int32)\ncounter_id: int;\n@serialize(int64)\ninc_by: int;\n\n\nEach of these quickly breaks down when handling more complex cases. \n\nFor example, how would we handle TL-B Maybe int32? Would we write:\n\n// this?\ninc_by: (int as int32)?;\n// or this?\ninc_by: int? as int32?;\n// or this?\ninc_by: Maybe<int> as Maybe<int32>;\n\n\nAnd what about TL/B Both (Maybe int32) int64?\n\n// this?\nmy_data: Both<Maybe<int as int32>, int as int64>;\n// or this?\nmy_data: Both<Maybe<int>, int> as Both<Maybe<int32>, int64>;\n// or how??\n\n\nWith every new case, the syntax becomes more complex, ambiguous, and error-prone.\n\nâœ” The solution: `int32` as a first-class type\n\n\nstruct CounterIncrement {\n    counter_id: int32;\n    inc_by: int64;\n}\n\n\nNo annotations. No confusing as syntax. No ambiguity.\n\nThis scales perfectly:\n\nstruct MyMsg {\n    inc_by: int32?;\n    my_data: (int32?, int64);\n}\n\n\nThese are distinct types. A variable can be int32 and similar:\n\nvar op: int32 = ...;\nvar query_id: uint64 = ...;\n\n\nThis makes serialization predictable, structured, and error-free.\n\nâœ” What about overflow?\n\nA reasonable question: what happens if a value exceeds the limit?\n\nvar v: uint8 = 255;\nv += 1;    // ???\n\n\nAnswer: no runtime overflow or clamping! It's just int at TVM.\n\n* arithmetic works normally â€“ v becomes 256\n* no extra gas cost â€“ no runtime bounds checks\n* overflow will only happen at serialization\n\n\nstruct Resp {\n    outValue: uint8;\n}\n\nresp.outValue = v;   // 256\nresp.toCell();       // a runtime \"overflow\" error\n\n\nâœ” Why is this the best approach?\n\nThink of smart contracts as a black box:\n- inputs are encoded (int32, uint64, etc.)\n- inside the contract, arithmetic uses full 257-bit precision\n- outputs are serialized again â€” overflow happens only at this stage\n\nThis is similar to how mulDivFloor(x,y,z) uses 513-bit precision internally. Your contract keeps precision internally and only enforces constraints at the border with an outside world.\n\nğŸŒ³ Tolk will follow a type-based philosophy\n\nThis post covered the foundation of automatic serialization. The right way is to have a rich type system. Having nested types, having generics, having aliases â€” will allow to describe every practical TL/B case, but at a language level.\n\nIn v0.10, we introduce intN (fixed integers), bytesN (definite slices), coins (variadic integers), and some more additions. Read the details in the PR.\n\nHow will Either L R and even more complex TL/B structures be expressed? \nStay tuned for the next update..."
    },
    {
      "id": 19,
      "type": "message",
      "date": "2025-04-08T09:12:01.000Z",
      "date_unixtime": "1744103521",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "ğŸ«§ Tolk v0.11: type aliases, union types, and pattern matching\n\nThis update might confuse you at first. You may wonder: \"Why do we need this? How will it be useful?\". But in the end, you'll see how everything comes together bringing seamless and generalized message handling.\n\nâœ… Notable changes in Tolk v0.11:\n\n1. Type aliases type NewName = <existing type>\n2. Union types T1 | T2 | ...\n3. Pattern matching for types\n4. Operators is and !is\n5. Pattern matching for expressions\n6. Semicolon for the last statement in a block can be omitted\n\nPR on GitHub with detailed info.\n\nâœ” Type aliases\n\nTolk now supports type aliases, similar to TypeScript and Rust.\n\n\ntype UserId = int32;\ntype MaybeOwnerHash = bytes32?;\n\n\nAn alias creates a new name for an existing type but remains interchangeable with it. No performance overhead â€” a compile-time feature.\n\nâœ” Union types `T1 | T2 | ...`\n\nThey now allow a variable to hold multiple possible types. \n\n\nfun whatFor(a: bits8 | bits256): slice | UserId { ... }\n\nvar result = whatFor(...);  // slice | UserId\n\n\nNullable types T? are now formally T | null. \n\nAt the TVM level, union types work as tagged unions â€” similar to Rust enums but more flexible.\n\nâœ” Pattern matching\n\nThe only way to work with union types is matching them:\n\n\nmatch (result) {\n    slice  => { /* result is slice here  */ }\n    UserId => { /* result is UserId here */ }\n}\n\n\nMatching is based on smart casts â€” inside each branch, the variable is automatically narrowed to the matched type.\nÂ \nIt can also be used as an expression:\n\n\ntype Pair2 = (int, int);\ntype Pair3 = (int, int, int);\n\nfun getLast(tensor: Pair2 | Pair3) {\n    return match (tensor) {\n        Pair2 => tensor.1,\n        Pair3 => tensor.2,\n    }\n}\n\n\nSo, `match` + smart casts are our way for union types. You may notice that it's close to enums in Rust. But we don't have enum. Union types are more general and powerful.\n\nâœ” `match` for expressions\n\n\nval nextValue = match (curValue) {\n    1 => 0,\n    0 => 1,\n    else => -1\n};\n\n\nAs you see, match also works for constant expressions, similar to switch in other languages.\n\nâœ” Union types and TL/B `Either`\n\nT1 | T2 will be directly mapped to TL-B (Either T1 T2). \nLook how clean this is: (Either SmallPayload LargePayload) becomes\n\n\nstruct StoragePart {\n    data: SmallPayload | LargePayload;\n    // (de)serialized as '0' + ... or '1' + ...\n}\n\nmatch (s.data) {\n    SmallPayload => ...\n    LargePayload => ...\n}\n\n\nNo need to manually handle bits from the slice â€” it's naturally expressed in the type system!\n\nâœ” Union types and TL/B constructors\n\nT1 | T2 | ... is a typed way to describe multiple constructors from TL/B. Generally, they can be used anywhere inside a storage or a message. \n\nMoreover â€” handling incoming messages is beautifully expressed with union types.\n\nâœ” Union types and future structures\n\nThe ultimate goal? You'll describe each incoming message as a struct, create a union type for them, parse a slice, and just match over variants:\n\n\n// don't mind about opcodes yet\nstruct CounterIncBy { byValue: int32 }\nstruct CounterReset {}\nstruct ... other messages\n\ntype IncomingMessage = CounterIncBy | CounterReset | ...;\n\n// ... after parsing a message\nmatch (msg) {\n    CounterIncBy => {\n        newCounter = curCounter + msg.byValue\n    }\n    CounterReset => {\n        newCounter = 0\n    }\n    ...\n}\n\n\nğŸŒ³ So, union types (that perfectly work with tensors) will seamlessly work with structures. With union types, you will declare both Either and different kinds of messages. Combined with intN and other types, they will allow to express (almost) any practical TL/B construction. They are not limited to message routing â€” in other words, message routing does not differ from handling any field, any storage, or any cell in general."
    },
    {
      "id": 21,
      "type": "message",
      "date": "2025-05-30T09:12:01.000Z",
      "date_unixtime": "1748596321",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "ğŸ«§ Tolk v0.13 (Release candidate): Auto-packing to/from cells\n\nWe've finally reached the point we've been working toward for the past six months: automatic (de)serialization of anything into cells. From simple structs to unions, generics, and even nested references â€” it just works.\n\nThe goal? To replace TL/B entirely with declarative, type-safe definitions. The compiler takes care of packing, loading, estimating, error handling, and more.\n\nâœ… Notable changes in Tolk v0.13:\n\n1. Auto-packing to/from cells/slices/builders\n2. Type address\n3. Lateinit variables, default parameters, and other minor features\n\nPR on GitHub with detailed info.\n\nâœ” Auto-serialization: short demo\n\n\nstruct Point {\n    x: int8;\n    y: int8;\n}\n\nvar value: Point = { x: 10, y: 20 };\n\n// makes a cell containing \"0A14\"\nvar c = value.toCell();   \n// back to { x: 10, y: 20 }   \nvar p = Point.fromCell(c);\n\n\nKey features:\n\n* supports all types: unions, tensors, nullables, generics, atomics, ...\n* allows to specify prefixes (particularly, opcodes)\n* allows to manage cell references and when to load them\n* lets you control error codes and other behavior\n* unpacks data from a cell or a slice, mutate it or not\n* packs data to a cell or a builder\n* warns if data potentially exceeds 1023 bits\n* more efficient than manual serialization\n* will seamlessly integrate with message sending/receiving in Tolk v1.0\n\nâœ” Pack or unpack â€” anywhere\n\nT.fromCell, T.fromSlice, slice.loadAny<T>, builder.storeAny<T>, and other methods give both high-level and low-level API.\n\n\n// low-level is allowed:\nbeginCell()\n  .storeUint(1, 32)    // mix manual\n  .storeAny(myStruct)  // with auto\n\n\nâœ” Serialization prefixes and opcodes\n\n\nstruct (0x7362d09c) TransferNotification {\n    queryId: uint64;\n    ...\n}\n\n\nThey are not limited to 32 bitsÂ â€” you can describe any TL/B constructors:\n\nstruct (0b001) AssetSimple { ... }\nstruct (0b100) AssetBooking { ... }\ntype Asset = AssetSimple | AssetBooking | ...;\n\n\nâœ” Typed cells\n\n\nstruct A {\nÂ  Â  ref1: cell; Â  Â  Â  Â   // untyped ref\nÂ  Â  ref2: Cell<Inner>;Â   // typed ref\nÂ  Â  ref3: Cell<int256>?; // maybe ref\n}\n\n\nTyped cells give you full control over when content is unpacked â€” nothing is loaded unless you call .load() manually:\n\na.ref2.field         // error\na.ref2.load().field  // ok\n\n\n// Yes, point.toCell() really gives you Cell<Point>\n\nâœ” Granular options\n\nAccurately adjust serialization behaviour (for example, error codes):\n\n\nPoint.fromSlice(s, {\n    assertEndAfterReading: false\n})\n\n\nâœ” Built-in type `address`\n\n\nstruct Wallet {\n    owner: address;\n}\n\n\n* integrated with auto-serialization, while still a slice under the hood\n* comparable: if (senderAddress == wallet.owner)\n* introspectable: isInternal(), getWorkchain(), etc.\n\nâœ” Some other features\n\nDescribed in detail in the full changelog and mirrored in the documentation.\n\nğŸŒ³ We're just a couple of steps away from Tolk v1.0 â€” with message sending and handling, gas optimizations, and one secret feature. There is still a lot of work ahead, but today we're closer to the release than ever before."
    },
    {
      "id": 23,
      "type": "message",
      "date": "2025-07-07T09:12:02.000Z",
      "date_unixtime": "1751879522",
      "from": "Unknown",
      "from_id": "unknown",
      "text": "ğŸ«§ Tolk v1.0: lazy loading, partial updating, AST inlining â€” and extremely low gas fees\n\nThis is happening today. \n\nI managed not only to finish up the compiler, but also to migrate standard contracts from FunC to Tolk. \n\nI covered every contract with gas metrics to check whether it's more efficient than FunC or not. I didn't believe my eyes. I double-checked, triple-checked, but nothing changed. The results are correct. And now I am ready to present them to you.\n\nğŸ§ª Benchmarks!\n\nEvery contract has several metrics. For example, \"basic jetton â€” mint\". \nFunC: 19278. Tolk: 11611. \nGas savings: -39.77%\n\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   01 â€” Jetton (mint, transfer, burn, discover)\n|   -39.77%   |   -30.32%   |   -33.66%   |   -26.75%\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   02 â€” NFT (deploy, transfer, onchain get)\n|   -43.79%   |   -37.47%   |   -44.28%\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   03 â€” Notcoin\n|   -35.72%   |   -27.98%   |   ...\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   04 â€” tgBTC\n|   -23.94%   |   -26.99%   |   ...\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   05 â€” Wallet v5\n|   -21.66%   |   -22.92%   |   ...\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   06 â€” Vesting\n|   -45.30%   |   -29.61%   |   ...\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n|   07 â€” Telegram gifts\n|   -54.81%   |   -39.39%   |   ...\n|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“-\n\nI have migrated 7 contracts â€” preserving the original behavior and passing the same tests.\n\nAll benchmarks are open. No cheating. Just a smart compiler â€” and a language designed to be optimized.\n\nâ€” Even wallet?! But it's very low-level and tricky!\n\nEven wallet. You just express your thoughts without any tricks â€” and it works automatically. \n\nâ€” But how? How is it possible to achieve such numbers?\n\nOf course, I've put a lot of smartness into the compiler. A strong type system. Automatic inlining. Built-in serialization. The magic lazy keyword.\n\nBut first of all, Tolk is built for readability. These contracts aren't \"just cleaner\" than their FunC equivalents â€” they're elegant. No magic. No low-level intrigues. Just clean, consistent logic â€” whether it's a Jetton or a Wallet.\n\nAnd gas savings? They are a consequence. I didn't micro-optimize. Each contract was rewritten in about a day â€” just focusing on clarity. The core principle is simple: once you make it elegant, it automatically becomes efficient.\n\n\nâœ… Notable changes in Tolk v1.0:\n\n1. Lazy loading â€” only read what you actually use\n2. AST-based inlining â€” zero-cost getters and methods\n3. Peephole optimizations, TVM-11 â€” smaller code, lower gas\n\nPR on GitHub with detailed info.\n\nJust take a look: \n\nval st = lazy Storage.load();\n// the compiler skips everything and loads only what you access\nreturn st.publicKey;\n\n\nThat's it. Lazy loading and partial updates (calculating immutable slices for writing) â€” one magic lazy keyword to rule them all.\n\nâš™ï¸ The Release. What's inside\n\n- JetBrains IDE plugin â€” with completion, resolving, etc... âœ“ done\n- VS Code Extension â€” with suggestions, stdlib integration, etc... âœ“ done\n- Language server â€” for any LSP-compatible editor... âœ“ done\n- FunC-to-Tolk converter â€” migrate a project in 10 seconds... âœ“ done\n- Documentation â€” for smooth transition from FunC... âœ“ done\n\nAnd the TOLK language itself â€” exactly as I've visioned it... 7 months ago\n\n\nğŸ“… The essence of Numbers\n\nAt this moment, abstract yourself from the text. Take a look at the calendar.\n\nToday is 07/07/25 (I mean 2+5, of course).\n\nAfter the TON Gateway, throughout all November, I was laying out the roadmap towards Tolk v1.0. On December 1, I started working. It means, that the journey till now took exactly 7 months 7 days. If you scroll this channel to the top, you'll see an announcement... Of Tolk v0.7\n\nğŸª What's next?\n\nI could have written about my plans â€” for the language, TVM, ABI, TypeScript wrappers... but I won't.\n\nBecause today, instead of rushing into the future, maybe we can allow ourselves to look back.\nTo pause the endless race â€” just for a moment.\nTo notice how many beautiful coincidences pass us by â€” unnoticed in our constant hurry.\n\nJust step outside.\nClose your eyes.\nCount to seven.\nFeel it.\n\nWhen you're ready â€”\nLet's Tolk"
    }
  ]
}